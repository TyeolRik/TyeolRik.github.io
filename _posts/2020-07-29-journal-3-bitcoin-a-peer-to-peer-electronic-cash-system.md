---
layout: post
title: "[논문리뷰] Bitcoin: A Peer-to-Peer Electronic Cash System"
section-type: post
category: Journal
tags:
  - bitcoin
  - blockchain
  - cyptocurrency
---

## Author

<p style="text-align: center;">Satoshi Nakamoto (Unknown)</p>

<p style="text-align: center;">in <i>www.bitcoin.org</i></p>
<br><br>
Original Link: [Where did I find](https://bitcoin.org/bitcoin.pdf)<br>
Archived Link: [Download in Google Drive](https://drive.google.com/file/d/12wgPBRVSF6cNvU0z03mhHSkm1VzR7aw0/view?usp=sharing)

## 필자요약


## Introduction

현행의 전자 결제 시스템은 **신뢰 기반 모델에 기초**[^1]해있으므로 근본적으로 취약점이 존재한다. 또한, 완전 Non-reversible transaction[^2]이 불가능하다. Reversal이 가능하게 하기 위해서 신뢰할만한 Spreads가 필요하다.

필요한 것은 신뢰대신에 **암호학적 증명을 기반**으로한 전자 화폐이다. 그러니깐 제 3자의 개입(은행이나 어떤 공식기관) 없이 송신자 / 수신자가 직접 거래할 수 있는 그런 것이다. 결제시스템이 계산적으로 Non-Reversible 하면, 판매자로 하여금 사기(안 보냈는데 보냈다고 하는)를 방지할 수 있고 구매자를 보호하기 위한 에스크로 서비스(전자 결제)를 구현하는데 필요한 Routine을 쉽게할 것이다.

본 논문은 **이중 지불 문제(Double Spending Problem)[^3]를** Peer-to-Peer 분산 타임스탬프 서버가 Transaction의 시간적 순서를 이용한 계산적 증명을 이용해서 **해결하는 방법**을 제시하는 것에 목적이 있다. 본 시스템은 **신뢰할만한 Node의 CPU 파워가 Attacker node의 CPU 파워보다 더 클 때**는 안전하다.

## Transaction

![Imgur](https://i.imgur.com/jGUqPGp.png)

Electronic coin이란 디지털 서명의 Chain이다. 각각의 코인 소유자는 코인의 마지막에 이전 Transaction에 대한 디지털 서명과 Public key를 적어서(추가해서) 다음 소유자에게 넘긴다. 수령인은 서명을 Ownership의 Chain에 의해 검증할 수 있다. (8장에서 재설명)

이 과정의 문제점은 수령인이 코인 소유자 중의 한명이 이중 지불[^3]을 했는지 안했는지에 대한 검증을 할 수 없다는 것이다. 일반적인 해결책으로 매 Transaction을 조폐국과 같은 Mint(중앙시스템)에서 해결해주는 것이 있는데 이것은 일반적인 은행이랑 다를게 없다. 그리고 이 방식은 전적으로 어떤 Mint 회사에 종속되어 있는 것이므로 화폐 시스템 자체에 대한 신뢰성 문제가 존재한다. (예를 들어서, 어떤 회사가 잘 하고 있다가 악의적인 마음을 품거나 그렇다면?)

그러므로 수령자가 이 돈이 이전에는 한번도 결제되지 않았다(이중결제되지 않았다.)는 것을 알아차릴 수 있는 방법이 필요하다. 그 방법으로, 시간적으로 먼저 결제된 것만 count하고, 그 뒤에 결제된 것은 신경쓰지 않기로 하였다. Mint(중앙시스템) 기반 시스템에서, 중앙시스템은 모든 거래를 알고 어떤 요청이 먼저인지를 알고있다. 이 방법을 수행하기 위해서, 거래자체가 public하게 공개되어야하며, 하나의 History에 어떤 요청을 받았는지를 기록하기로 모든 참여자가 동의해야한다. 그리고 수령자가 매 Transaction 마다 대다수의 Nodes가 처음 이 요청을 받았음에 동의해야 한다. ~~그러므로, 신뢰할만한 node의 CPU 파워가 Attacker Node의 CPU파워보다 커야한다.~~

## Timestamp Server

![Imgur](https://i.imgur.com/kopbR8o.png)

위에서 제안한 방법은 Timestamp server를 만드는 것에서 시작한다. Timestamp Server는 타임스탬프가 찍힌 아이템들의 블록들의 해시들을 받고, Newspaper나 Usenet Post 같은 곳에 공개함으로써 작동한다. Timestamp가 해시에 들어가기 위해서 명백히 그 시간대에 존재한다는 사실을 증명한다. 각각의 Timestamp는 해시에 있는 이전 Timestamp를 포함하며, 체인을 이룸으로써 이전의 Timestamp가 반드시 존재해야함을 강제한다. ~~이전 Timestamp을 기입하고 지금 Timestamp를 기록해서 동일 History(Database)를 쓰겠다는 의미.~~

## Proof of Work

Peer-to-Peer 기반의 분산 Timestamp server를 구현하기 위해서, Proof-of-Work 시스템을 사용할 것이다. (Newspaper나 Usenet Post에 공지하는 것이 아니라.) Proof-of-Work 는 SHA-256 같은 해시알고리즘을 사용한 결과가 0비트 여러개로 시작하는 특정 값을 찾는 작업을 포함한다. ~~뭔 소리지?~~ 보통 요구되는 작업은 0비트의 개수에 따라 지수적으로 달라지며, 해시연산을 한번만 하면 verify 할 수 있다.

![Imgur](https://i.imgur.com/5NjSSkd.png)

Timestamp Network 에서 블록의 해시에 필요한 0비트를 주는 값이 발견될 때까지 블록 안에 Nonce를 증분하는 것으로 Proof-of-Work를 구현하였다. 위 사진 처럼, CPU가 한번 Proof-of-Work를 충족하는데 사용됐다면, 이 작업들을 다시 하지 않는 이상 변경될 수 없다. 예를 들어서, 100번째 블록을 변경하고 싶다면 1~99번 블록을 모두 다시 연산해야할 것이다.

Proof-of-Work는 다수결의 대표를 결정하는 문제를 해결할 수도 있다. 만약에 하나의 IP당 하나의 투표를 할 수 있다면, IP를 많이 할당받은 사람이 전체를 장악할 것이다. 그래서 Proof-of-Work는 필수적으로 CPU 당 1 투표가 되어야한다. Majority Decision은 가장 긴 체인으로 표현된다. 왜냐하면, 가장 긴 체인이 가장 Proof-of-Work에 기여를 많이 했을 것이기 때문이다. 만약, 다수의 CPU 파워가 가장 정직한 노드들에 의해 통제된다면, 가장 정직한 체인은 가장 빠르게 성장할 것이고 이는 다른 체인들을 압도할 것이다. 지난 블록을 수정하려면, 공격자는 현재와 그 이전의 모든 블록들에 대해서 Proof-of-Work 작업을 다시 해야하고 심지어 그 속도를 능가하여 가장 정직한 노드보다 빨라야할 것이다.

하드웨어 속도와 변화하는 Interest에 보상하기 위해서 Proof-of-Work 난이도는 시간당 평균 블록 수의 평균 목표치를 향해서 조정될 것이다. 너무 빠르게 만들어지면 난이도가 올라갈 것이다.

## Network

1. 새로운 Transaction 들은 모든 노드들에 Broadcast 되어야한다.
2. 각각의 노드들은 새로운 Transaction들을 블록에 담아야한다.
3. 각각의 노드들은 그 블록의 작업 난이도를 찾는 작업을 해야한다.
4. 만약, 어떤 노드가 Proof-of-Work를 찾았다면, 모든 노드들에게 이 사실을 알려야한다.
5. 오직, 블록에 있는 모든 Transaction 들이 유효하고, 아직 지불(Spent)되지 않았다면 노드들은 블록을 받아들여야한다.
6. 노드들은 이전 블록으로서 체인에 Accept 된 블록의 해시값을 사용하여 다음 블록을 만드는 것으로서 블록을 받아들였음을 표현해야한다.

노드들은 항상 제일 긴 체인을 고려하고 그것을 더 늘리려고 노력해야한다. 만약에 두 노드가 서로 다른 버전의 다음 블록을 동시에 만들어 발표했다면, 몇몇 노드들은 하나를 먼저 수신할 것이다. 이 경우에는 먼저 받은 것에 작업하고, 다른 가지가 더 길어질 것을 생각해서 저장해놓는다. 분명히 다음 Proof-of-Work에서 어느 한 가지가 더 길어질 것이고, 작업 중인 Branch는 더 긴것으로 바뀔 것이다.

새로운 Transaction Broadcast 들은 모든 노드에 닿을 필요는 없다. 많은 노드에 도달할 수록, 길어지기전에 하나의 블록에 도달한다. 블록을 못 받을 경우, 다음 블록을 받을 때 하나가 빠졌다는 것 알아차리고 다시 요청할 것이기 때문에 메시지 누락에 대한 내성을 갖는다.

## Incentive

관례상, 블록의 첫번째 거래는 블록을 만든 사람이 소유한 새로운 코인의 시작을 의미하는 특별한 거래이다. 이것은 네트워크를 지원하는 노드들에 대한 인센티브를 더해주며, 처음으로 발행된 코인이 순환하는 길을 제공한다. 새 코인들을 꾸준히 추가하는 것은 금을 채굴하는 사람이 더 많을 금을 채굴하기 위해서 자원을 추가하는 것과 유사하다. 우리 경우에서는 CPU 파워랑 전기이다.

<br>
<br>
<br>
<hr/>

[^1]: 은행 간에는 서로 신뢰 관계가 있기 때문에 (정부의 보증, 법적 테두리) 내부 직원의 PC나 네트워크에 대한 보안이 예상외로 취약함을 시사한다.

[^2]: 현금거래 같은게 Non-Reversible 하다. 예를 들어서, 100만원을 불에 태웠다고 쳐보자. 아무도 모르게 태웠다고 쳤을 때, 100만원은 세상에서 없어진 돈이 맞다. 아무도 복구할 수 없다. 그러나, 뱅킹 시스템이 미쳐서 100만원을 송금했는데 날아갔다고 치자. 법적이나 은행이나 어떤 시스템이 이를 무조건적으로 감시하고 있고, 날아간 100만원을 다시 발행해서 복구할 수 있을 것이다.

[^3]: 이중지불문제란 예를 들어서 A의 통장에 딱 만원이 있다고 치자. B와 C에게 동시에 만원을 송금했다고 치자. 동시에 프로세스 되므로, B에게 송금할 때 A의 잔고를 확인하니 만원이 있으므로 송금 승인, C에게 송금할 때 A의 잔고를 확인하니 만원이 있으므로 송금이 승인된다. 그러므로 B에게 만원, C에게 만원이 송금되면, 결과적으로 A는 잔고에는 만원이 있음에도 불구하고 2만원이 송금되는.. 필자가 생각하기엔 거대한(?) 공유자원 문제로 보인다.